<?php

declare(strict_types=1);

namespace Support;

use Stringable;
use Symfony\Component\VarExporter\VarExporter;
use InvalidArgumentException;
use Throwable;

final class PhpStormMeta implements Stringable
{
    private readonly FileInfo $projectRoot;

    protected ?string $name = null;

    /** @var array<string, string> */
    protected array $argumentSets = [];

    /** @var array<string, array{functionFQN: string, argumentIndex: int, values: string}> */
    protected array $expectedArguments = [];

    public function __construct(
        ?string $projectRoot = null,
    ) {
        $projectRoot ??= getProjectRootDirectory();
        $this->projectRoot = new FileInfo( "{$projectRoot}/.phpstorm.meta.php/" );
    }

    public function name( string $name ) : self
    {
        $this->name = $name;
        return $this;
    }

    public function registerArgumentsSet( string $name, mixed ...$arguments ) : self
    {
        $this->argumentSets[$name] = $this->exportArguments( ...$arguments );
        return $this;
    }

    /**
     * @param array{0: class-string, 1: string}|callable|callable-string|string $functionReference
     * @param array<int, string>|int                                            $argument          $index or [$index => $argumentsSetName]
     * @param mixed                                                             ...$arguments
     *
     * @return self
     */
    public function expectedArguments(
        array|string|callable $functionReference,
        int|array             $argument = 0,
        mixed              ...$arguments,
    ) : self {
        $reference = $this->referenceString( $functionReference );

        if ( \is_int( $argument ) ) {
            $this->expectedArguments[$reference] = [
                'functionFQN'   => $reference,
                'argumentIndex' => $argument,
                'values'        => $this->exportArguments( ...$arguments ),
            ];
        }
        else {
            foreach ( $argument as $key => $value ) {
                $this->expectedArguments[$reference] = [
                    'functionFQN'   => $reference,
                    'argumentIndex' => $key,
                    'values'        => "argumentsSet('{$value}')",
                ];
            }
        }

        return $this;
    }

    public function __toString()
    {
        $content = ['namespace PHPSTORM_META;'];

        foreach ( $this->argumentSets as $name => $argumentSet ) {
            $content[] = "registerArgumentsSet('{$name}', {$argumentSet});";
        }

        foreach ( $this->expectedArguments as $expectedArguments ) {
            $expectedArguments = \implode( ",\n    ", $expectedArguments );
            $content[]         = "expectedArguments(\n\t{$expectedArguments}\n);";
        }

        return \implode( "\n\n", $content );
    }

    /**
     * @param string $fileName
     *
     * @return void
     */
    public function save( string $fileName ) : void
    {
        $fileName = '.'.Normalize::key( \trim( $fileName, './\\' ), '_' ).'.meta.php';

        $fileInfo  = $this->projectRoot->append( $fileName );
        $generator = '\\'.$this::class;
        $generated = new Time();
        $timestamp = $generated->unixTimestamp;
        $date      = $generated->datetime;

        $name = Normalize::key( $this->name ?? \trim( $fileInfo->getFilename(), '.' ), '.' );

        $timestamp = "#{$timestamp}#";

        $meta = <<<PHP
            <?php
            
            /*--------------------------------------------------------{$timestamp}-
            
               Name      : {$name}
               Generated : {$date}
            
               This file is generated by {$generator}.
            
               Do not edit it manually.
            
            ---------------------------------------------------------------------*/
            
            {$this->__toString()}
            PHP;

        $fileInfo->save( $meta );
    }

    /**
     * @param array{0: class-string, 1: string}|callable|callable-string|string $functionReference
     *
     * @return string
     */
    private function referenceString( array|string|callable $functionReference ) : string
    {
        try {
            [$class, $method]  = explode_class_callable( $functionReference );
            $functionReference = "\\{$class}::{$method}()";
        }
        catch ( Throwable $exception ) {
            if ( ! \is_string( $functionReference ) || ! \str_ends_with( $functionReference, '()' ) ) {
                throw new InvalidArgumentException(
                    __METHOD__.' could not parse $functionReference.',
                    $exception->getCode(),
                    $exception,
                );
            }
        }
        return $functionReference;
    }

    private function exportArguments( mixed ...$arguments ) : string
    {
        try {
            return VarExporter::export( $arguments );
        }
        catch ( Throwable $exception ) {
            throw new InvalidArgumentException(
                $exception->getMessage(),
                $exception->getCode(),
                $exception,
            );
        }
    }
}
